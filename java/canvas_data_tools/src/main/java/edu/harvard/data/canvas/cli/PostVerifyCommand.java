package edu.harvard.data.canvas.cli;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.ExecutorService;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.Option;

import edu.harvard.data.AwsUtils;
import edu.harvard.data.DataConfigurationException;
import edu.harvard.data.ReturnStatus;
import edu.harvard.data.VerificationException;
import edu.harvard.data.Verifier;
import edu.harvard.data.canvas.CanvasDataConfig;
import edu.harvard.data.canvas.phase_0.Phase0PostVerifier;
import edu.harvard.data.canvas.phase_1.Phase1PostVerifier;
import edu.harvard.data.canvas.phase_2.Phase2PostVerifier;
import edu.harvard.data.canvas.phase_3.Phase3PostVerifier;
import edu.harvard.data.schema.UnexpectedApiResponseException;

public class PostVerifyCommand implements Command {

  private static final Logger log = LogManager.getLogger();

  @Argument(index = 0, usage = "Verification phase.", metaVar = "0", required = true)
  public int phase;

  @Option(name = "-i", usage = "UUID for the dump, generated by the Canvas Data API. Required for phase 0.", metaVar = "uuid", required = false)
  public String dumpId;

  @Option(name = "-in", usage = "Location of original data files. Required for phases > 0.", metaVar = "/path/to/data", required = false)
  public String inputDir;

  @Option(name = "-out", usage = "Location of processed data files. Required for phases > 0.", metaVar = "/path/to/data", required = false)
  public String outputDir;

  @Option(name = "-verify", usage = "Location of verification files. Required for phases > 0.", metaVar = "/path/to/verify", required = false)
  public String verifyDir;

  @Override
  public ReturnStatus execute(final CanvasDataConfig config, final ExecutorService exec)
      throws IOException, DataConfigurationException, UnexpectedApiResponseException,
      ArgumentError {
    if (!checkArguments()) {
      return ReturnStatus.ARGUMENT_ERROR;
    }
    try {
      final Verifier verifier = getVerifier(config, exec);
      verifier.verify();
    } catch (final VerificationException e) {
      log.error("Verification Exception", e);
      return ReturnStatus.VERIFICATION_FAILURE;
    }
    return ReturnStatus.OK;
  }

  private Verifier getVerifier(final CanvasDataConfig config, final ExecutorService exec)
      throws ArgumentError, DataConfigurationException {
    final URI hdfsService;
    try {
      hdfsService = new URI("hdfs///");
    } catch (final URISyntaxException e) {
      throw new DataConfigurationException(e);
    }
    final AwsUtils aws = new AwsUtils();
    switch (phase) {
    case 0:
      return new Phase0PostVerifier(dumpId, aws, new File(config.scratchDir), exec);
    case 1:
      return new Phase1PostVerifier(hdfsService, inputDir, outputDir, verifyDir);
    case 2:
      return new Phase2PostVerifier();
    case 3:
      return new Phase3PostVerifier();
    }
    throw new ArgumentError("Invalid phase " + phase);
  }

  private boolean checkArguments() throws DataConfigurationException {
    if (phase == 0) {
      if (dumpId == null) {
        log.error("Dump ID is required for Phase 0");
        return false;
      }
    } else {
      outputDir = checkPath(outputDir);
      inputDir = checkPath(inputDir);
      verifyDir = checkPath(verifyDir);
    }
    return true;
  }

  private String checkPath(final String dir) throws DataConfigurationException {
    if (dir == null) {
      throw new DataConfigurationException("Input directory is required for all phases other than zero.");
    }
    if (!dir.toLowerCase().startsWith("hdfs://")) {
      return "hdfs://" + dir;
    }
    return dir;
  }

  @Override
  public String getDescription() {
    return "Perform verification operations following a phase.";
  }

}
